<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>4 Developer's Guide 1.3.4-SNAPSHOT</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/overview.html"><strong>1</strong><span>Overview</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/installation.html"><strong>2</strong><span>Installation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/usersGuide.html"><strong>3</strong><span>User's Guide</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/developersGuide.html"><strong>4</strong><span>Developer's Guide</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/faq.html"><strong>5</strong><span>Frequently Asked Questions</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        
    </div>
    <p>jCatalog Software AG</p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/usersGuide.html">&lt;&lt; <strong>3</strong><span>User's Guide</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/faq.html"><strong>5</strong><span>Frequently Asked Questions</span> >></a></div>
                


                <div class="project">
                    <h1>4 Developer's Guide - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Stephan Albers, July Antonicheva</p>

                    <p><strong>Version:</strong> 1.3.4-SNAPSHOT</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>4.1</strong><span>Overview</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#nodeOwner"><strong>4.2</strong><span>Changing a Node Owner dynamically</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#actions"><strong>4.3</strong><span>Creating Actions</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#extStartProcess"><strong>4.4</strong><span>Extendable Start Process</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#varForms"><strong>4.5</strong><span>Generating forms from Variable definitions</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#manualForms"><strong>4.6</strong><span>Manual Forms</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#manualFormsActions"><strong>4.7</strong><span>Manual Forms Actions</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#postKillHandler"><strong>4.8</strong><span>PostKillOperation Handler</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#customizeDueDate"><strong>4.9</strong><span>Customize Due Dates calculation</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="developersGuide">4 Developer's Guide</h1>



<h2 id="introduction">4.1 Overview</h2>
This section gives you a brief overview about the structure of GrailsFlow and how the system works internally.<p class="paragraph"/>The most important components are:
<ul class="star">
<li>Process definitions</li>
<li>Processes</li>
<li>Process variables</li>
<li>Worklist management</li>
<li>Actions</li>
<li>Documents</li>
</ul><p class="paragraph"/><strong class="bold">Process Definitions</strong><p class="paragraph"/>The workflow engine consists of process definitions and information about running processes. They define the basic
steps of a process. We call these steps nodes.<p class="paragraph"/>Process Definitions are stored in Groovy classes using the builder syntax. You find examples in
web-app/WEB-INF/workarea/processes/ in your GrailsFlow directory.<p class="paragraph"/>When editing processes, this information gets parsed and stored into ProcessDef and ProcessDefNodes. After the editing
process GrailsFlow creates new Groovy files from these definitions.<p class="paragraph"/>The node types are:
<ul class="star">
<li>activity node - the system executes the Groovy code stored in the node ;</li>
<li>fork node - engine allows splits for the parallel execution of multiple steps. Split nodes mark the beginning of</li>
</ul><p class="paragraph"/>a parallel execution
<ul class="star">
<li>join node - the counterpart to split nodes, where multiple parallel executions are joined together</li>
<li>wait node - wait nodes expect user input. When the process execution reaches a wait node, the node becomes</li>
</ul><p class="paragraph"/>visible in the worklist. Typically the user enters or changes values of process variables or makes decisions about
where to go to next (decides for/specifies an event).<p class="paragraph"/>
We move from node to node via so called "events" (also called transitions). When a node gets executed it returns a
value (name of the event). Based on this value the workflow engine moves to the next node that is connected via
this event.<p class="paragraph"/><strong class="bold">Processes</strong><p class="paragraph"/>Running Processes as well as historical information is stored in:
<ul class="star">
<li>Process and</li>
<li>ProcessNode</li>
</ul><p class="paragraph"/>Whenever a process enters a new node, a process node record is created in the database. After the process leaves the
nodes, the record gets updated with status information.<p class="paragraph"/>This means ProcessNode includes all historical information about the process. When the process enters the same node
twice, there are two records for this node.<p class="paragraph"/>This makes it easy to see the status of running or old processes by looking at the process and processNodes tables.<p class="paragraph"/><strong class="bold">Start process: Extendable Process Starting</strong><p class="paragraph"/>There is a possibility to start Process/send Event with the help of external groovy scripts located in
src/samples/callbacks/. These scripts are called on /process/executeCallback/&#60;scriptFileName&#62; URL request. For example,
request of /process/executeCallback/sendEvent will invoke execution of callbacks/sendEvent.groovy script.<p class="paragraph"/>Request, params and result are passed to callback script. Callback script should parse request to get
processKey, nodeID, event, process variables and to store them in the result parameter.<p class="paragraph"/>For example:
<ul class="star">
<li> result.processKey = params.processID</li>
<li> result.nodeID = params.nodeID</li>
<li> result.variables = productID: params.productId, catalogID: params.catalogID</li>
</ul><p class="paragraph"/>Based on the result of callback script execution, ProcessController would update process variables and invoke event of
appropriate node.<p class="paragraph"/>Parameters that are available in the callback script:
<ul class="star">
<li>request - HttpServletRequest instance,</li>
<li>params - String valued parameters passed to the ProcessController by request,</li>
<li>result - object for storing parsed process parameters.</li>
</ul><p class="paragraph"/>Script should fill following result properties:
<ul class="star">
<li>result.processKey - key of the process that should be executed,</li>
<li>result.nodeID  - name of the node that should be executed,</li>
<li>result.event  - event that should be send to the node,</li>
<li>result.requester (optional, default is logged user) - ID of the person that invokes event,</li>
<li>result.variables (optional) - map of name-&#62;value pairs of process variables that should be updated,</li>
<li>result.message (optional, default is "Callback received") - message to be send in response in case of successful execution,</li>
<li>result.statusCode (optional, default is 200) - HTTP status code to be send in response.</li>
</ul><p class="paragraph"/><strong class="bold">Process Variables</strong><p class="paragraph"/>Process Variables are all public variables declared in the process. The variables are read via reflection and stored
in the ProcessVariable class as a map. Whenever the variables have changed, they get stored back into the database.<p class="paragraph"/>Therefore, process variables are always persisted in the database, so that the process can go on, even after the
application has been restarted. However, process variables do not include any historic information, only the current
values. This is different from nodes, where we see the complete history in process nodes.<p class="paragraph"/><strong class="bold">Worklist management</strong><p class="paragraph"/>GrailsFlow supports automatic execution of nodes and manual user input. Workflows often need the user to make decisions
or give input to the process.<p class="paragraph"/>GrailsFlow has functions for worklist management integrated. Whenever a process designer specifies a wait node, the
execution of the process stops when reaching that node. The node becomes visible in the worklist of the user that is
currently assigned to that process node.<p class="paragraph"/>When a user clicks on the node there can be three possible interactions:
<ul class="star">
<li><strong class="bold">automatic forms</strong> -  user sees all process variables the process designer has given read access to and can enter</li>
</ul><p class="paragraph"/>values for variables. GrailsFlow also shows buttons for all events/transitions that leave the node, so the user can
decide which transition to take by clicking on the button.
<ul class="star">
<li><strong class="bold">manual form</strong> - GrailsFlow allows the upload of forms that have been defined manually. These forms are shown instead</li>
</ul><p class="paragraph"/>of the automatically generated form.
<ul class="star">
<li><strong class="bold">manual forms and controller</strong> - This allows process designers to define their own forms management and controllers.</li>
</ul><p class="paragraph"/>This is the most flexible way of interacting with the user, however, it is also takes the biggest effort. Controller can
deal with process variables or other Grails components as well as span multiple pages using the Grails WebFlow
functionality.<p class="paragraph"/><strong class="bold">Actions</strong><p class="paragraph"/>Grailsflow provides several pre-defined actions out of the box, eg. SendMail, Log, Evaluate. To define a new Action,
reate a new class that implements the Action interface and put it into "src&#103;roovy&#99;om&#106;catalog&#103;railsflow&#97;ctions".<p class="paragraph"/>GrailsFlow automatically collects the available actions and presents them in the action editor.<p class="paragraph"/>Actions can have parameters. These are defined as simple instance variables within the Action class. The action editor
automatically creates a user interface for the parameters and ask the user for the values.<p class="paragraph"/>The user can select three different value type for the parameter of an action: process variables, constant values or
arbitrary Groovy expressions.<p class="paragraph"/>At runtime, a new action is created, the values of the parameters or constants are assigned to the instance variables of
the action and the "execute" methods are called.<p class="paragraph"/><strong class="bold">Documents</strong><p class="paragraph"/>Documents are a special type of process variable that allows user's to store arbitray files in a process. You declare a
process variable in your process class through the Process Editor (or manually) with the type Documents. When the
variables can be entered, GrailsFlow presents an upload button for documents. The file is uploaded and stored in a
directory. We create one directory for each day. The file name is cleaned up and extended by the process id and a
counter. The link to the file is stored in the DB.<p class="paragraph"/>The file can be downloaded and a new version can be uploaded, if the variable can be changed in a later step (node).
The new version is stored the same way, so GrailsFlow provides a full version history for documents.



<h2 id="nodeOwner">4.2 Changing a Node Owner dynamically</h2>
Grailsflow allows user's to define assignees or owners of node. An assignee or node owner could be a specific user, a
list of roles or groups. These are the persons that see the workitems, work on them and move them to the next status.<p class="paragraph"/>The owners of a node are pre-defined in the process editor, however they can be overwritten within the workflow. When a
worklist is shown, the system checks for all nodes that have the same user id, roles or groups in the assignee list that
the current user has and shows those nodes in the worklist.<p class="paragraph"/>There are processes that require that the assignee of a node is determined/calculated dynamically, e.g some of them are
visible only for an administrator, some are available for simple users, others for restricted groups, etc.<p class="paragraph"/>GrailsFlow supports this by providing a system variable nextOwners that allows them to set the owners for the next
nodes. This variable is not stored in the DB, but evaluated while executing a node and lives only in the action
execution context.<p class="paragraph"/>When the actions of a node are finished, that next nodes are created and GrailsFlow writes "nextOwners" as the "owners"
into those nodes. In the definition of actions, they look and act like simple process variables.<p class="paragraph"/>The difference between 'nextOwners' and 'nextOwner' properties is that in 'nextOwners' , you can specify different
assignees for specific nodes, while 'nextOwner' allows you to specify assignees for all following nodes. This is more
convenient, if you have only one following node - in this case you do not need to specify 'nodeID' for that node.<p class="paragraph"/>The user names/roles/groups in assignees should have the same types/values, as the information coming from the
AbstractWorklistProvider implementation. This is typically "USER_username", "ROLE_rolename" and "GROUP_groupname".<p class="paragraph"/>Example: if you want to create restrictions for user roles and your user class contains many roles, then you will have
something like this in your process description:<p class="paragraph"/>In Process Definition:<p class="paragraph"/><div class="code"><pre>&#8230;
    action &#123;
      &#8230;
      AssignTo(<span class="java&#45;keyword">var</span>:'nextAssignee') &#123;
        Evaluate(expression: '&#91;<span class="java&#45;quote">"ROLE_USER"</span>, <span class="java&#45;quote">"ROLE_ADMIN"</span>&#93;')
      &#125;<p class="paragraph"/>    &#125;</pre></div>


<h2 id="actions">4.3 Creating Actions</h2>
<strong class="bold">Actions</strong><p class="paragraph"/>Actions are the principal unit that execute all activities and operations in GrailsFlow. They are written in plain
Groovy and stored in a specified folder. The folder can be customized in Spring configuration (like paths to processes
scripts and document attachments), by default it is configured to the 'actions' folder in the workarea. When the node
is executing, the necessary action script is loaded as a file, dynamically parsed to Java class and then executed
(method execute() of the class is called).<p class="paragraph"/>When you write a new action, you have to subclass the abstract class Action. All actions can then be used in the action
editor and the 'action' closure of the process definition.<p class="paragraph"/>
<strong class="bold">How to implement a custom action</strong><p class="paragraph"/>The class Action provides several methods that are further described here.
<ol>
<li>Execute() method</li>
</ol><p class="paragraph"/>The abstract Object execute() method need to be implemented. This methods "is" the actual action/does the operation that
the action does. The result that is returned from this method is used as the action result and can be assigned to
variable value or returned as the result of 'return' statement.
<ol>
<li>Helper method getObjectByName(String beanName)</li>
</ol><p class="paragraph"/>Allows to use preconfigured Spring beans in the context of an action. The beans are look up in the Spring context
configuration and if nothing is found - null result is returned. Can be used for arbitray operations eg. executing some
DB operation, integrating external beans etc.
<ol>
<li>Map actionInfo</li>
</ol><p class="paragraph"/>actionInfo contains basic information about the current process and execution context that can be used in the action
implementation. It provides the
<ul class="star">
<li>   process key,</li>
<li>   current node ID,</li>
<li>   locale,</li>
<li>   siteBase,</li>
<li>   requester.</li>
</ul><p class="paragraph"/>Grailsflow provides a number of basic actions that are useful in many workflows. Among them are:
<ul class="star">
<li>LogAction - writes some log information in the trace or the log file.</li>
<li>EvaluateAction - evaluates arbitrary Groovy expressions. This is very powerful and generic and reduces the number of</li>
</ul><p class="paragraph"/>actions that you need to write.
<ul class="star">
<li>SendMailAction - sends mail to the give recipient</li>
</ul><p class="paragraph"/>


<h2 id="extStartProcess">4.4 Extendable Start Process</h2>
In Grailsflow it is possible to start process in two ways:
<ul class="star">
<li> start process with defaults values by passing process name;</li>
<li> start process from external system (with requested variables values).</li>
</ul><p class="paragraph"/>In the first, you can start process with default values (pre-defined in process definition script). When you start the
process and your first node is manual (the node of type 'Wait') you will be automatically redirected to the manual form
and the process will be started only when you submit it (change/set values for the process variables).<p class="paragraph"/>But sometimes there is a situation when the external system wants to start the process. The system should provide the
starting data for process (the values for process variables). For example, the several different systems use the same
process definition 'CreateProduct' for creating product. For starting the process, the system should provide 'productId'
and 'catalogId' values. The problem is that systems can have (and usually have) different formats for sending
parameters, e.g. in XML. It means that for each and every system, a special 'parser' script is needed for parameters,
and then when Grailsflow gets the parameters in usual form it can start the process using standard procedure.<p class="paragraph"/>It is possible to start a process from an external system using Grailsflow 'Extendable StartProcess' feature. When you
want to use it you need:
<ol>
<li>Have a Groovy 'callback' script in application workarea (the application contains Grailsflow plugin installed). This</li>
</ol><p class="paragraph"/>script should be places in workarea directory according to 'callbacksPath' bean value. The bean is defined in
Grailsflow, and can be redefined in application, but the defauls value is "callbacks" folder.
Callback script should parse request to get process variables (and possibly processType and user) to store them in the
result parameter. Parameters that are available in the callback script:
<ul class="star">
<li>request - HttpServletRequest instance</li>
<li>params - String valued parameters passed to the ProcessController by request</li>
<li>result - object for storing parsed process parameters</li>
</ul><p class="paragraph"/>Parameters that should be provided in the 'result' map (in callback script):
<ul class="star">
<li>variables - (optional) - map of name:value pairs of process variables that should be used.</li>
<li>requester -  (optional, default is logged user) - ID of person that invokes event</li>
<li>processType - (required) - the name of process definition that should be started</li>
</ul>
<ol>
<li>Use URI for starting process:</li>
</ol><p class="paragraph"/>   <strong class="bold">process/extendedStartProcess/&#60;id&#62;</strong><p class="paragraph"/>where 'id' - is a Groovy callback script name.<p class="paragraph"/>Lets check the example: your system provides the parameters for starting in the following view (as XML):<p class="paragraph"/><div class="code"><pre>&#60;?xml version='1.0' encoding='UTF&#45;8'?&#62;
  &#60;test&#62; 
    &#60;DOCUMENT&#62;   
      &#60;PRODUCTID&#62;11240_Printer&#60;/PRODUCTID&#62;
      &#60;CATALOGID&#62;HP&#60;/CATALOGID&#62;   
      &#60;MANUFACTURER&#62;JC_MANUFACTURER&#60;/MANUFACTURER&#62;
      &#60;STATUS&#62;UPDATED&#60;/STATUS&#62; 
    &#60;/DOCUMENT&#62;
  &#60;/test&#62;</pre></div><p class="paragraph"/>You create script 'TestScript.groovy' that knows how to get parameters from request:<p class="paragraph"/><div class="code"><pre>// Parsing request body<p class="paragraph"/>def doc = request.XML
<span class="java&#45;keyword">if</span>(!doc || !doc.DOCUMENT) &#123;
  result.message = <span class="java&#45;quote">"Cannot parse request"</span> 
  result.statusCode = 500 
  <span class="java&#45;keyword">return</span>
&#125;
// Getting process parameters
def productId = doc.DOCUMENT&#91;0&#93;.PRODUCTID&#91;0&#93;
def catalogId = doc.DOCUMENT&#91;0&#93;.CATALOGID&#91;0&#93;
def manufacturer = doc.DOCUMENT&#91;0&#93;.MANUFACTURER&#91;0&#93;
ef SAP_Status = doc.DOCUMENT&#91;0&#93;.STATUS&#91;0&#93;<p class="paragraph"/>def variables = &#91;productId: productId,                
                 catalogId: catalogId,                
                 manufacturer: manufacturer,                
                 SAP_Status: SAP_Status&#93;<p class="paragraph"/>def securityHelper = applicationContext.getBean(<span class="java&#45;quote">"securityHelper"</span>)
<span class="java&#45;keyword">if</span> (!securityHelper) &#123; 
  result.message = <span class="java&#45;quote">"Security Helper bean is not configured."</span> 
  result.statusCode = 500 
  <span class="java&#45;keyword">return</span>
&#125;<p class="paragraph"/>result.processType = <span class="java&#45;quote">"TestProduct"</span>
result.requester = securityHelper.getUser(<span class="java&#45;keyword">null</span>)
result.variables = variables</pre></div><p class="paragraph"/>Then you place script 'TestScript' in workarea (in callbacksPath folder) and start the process by passing URL:<p class="paragraph"/>&#60;your_application_context_path&#62;/process/extendedStartProcess/TestScript<p class="paragraph"/>For example:<p class="paragraph"/> <em class="italic">http://localhost:8080/pim-grails/process/extendedStartProcess/TestScript</em> 



<h2 id="varForms">4.5 Generating forms from Variable definitions</h2>
<strong class="bold">Types of Forms</strong><p class="paragraph"/>Grailsflow supports automatic execution of nodes and manual user input. Workflows often need the user to make decisions
or give input to the process.<p class="paragraph"/>GrailsFlow has functions for worklist management integrated. Whenever a process designer specifies a wait node, the
execution of the process stops when reaching that node. The node becomes visible in the worklist of the user that is
currently assigned to that process node.<p class="paragraph"/>When he clicks on the node there are three possible interactions:
<ul class="star">
<li> <strong class="bold">automatic form:</strong> the user sees all process variables that the process designer has given read access to. He can enter</li>
</ul><p class="paragraph"/>values for variables. GrailsFlow also shows buttons for all events/transitions that leave the node, so the user can
decide which transition to take by clicking on the button.
<ul class="star">
<li> <strong class="bold">manual form:</strong> GrailsFlow allows to upload forms that have been defined manually. These forms are shown instead of the</li>
</ul><p class="paragraph"/>automatically generated form.
<ul class="star">
<li> <strong class="bold">manual forms and controller:</strong> This allows process designers to define their own forms management and their own</li>
</ul><p class="paragraph"/>controllers. This is the most flexible way of interacting with the user; however it is also the biggest effort.
Controller can deal with process variables or other Grails components and can also span multiple pages using the Grails
WebFlow functionality.<p class="paragraph"/><strong class="bold">Create a Form</strong><p class="paragraph"/>In the Process Editor under Process Nodes, click the "Add" button to create a node.<p class="paragraph"/>Enter Node ID and select type as 'Wait' to display the visibility section. Define the visibility for each of the
variables (INVISIBLE, READ_ONLY, REQUIRED and WRITE_READ). Select form generation as - "Use Automatic Form" and click
the "Save" button.<p class="paragraph"/>The user interface form is auto generated as below.<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/varForms_1.jpg"></img><p class="paragraph"/>The user interface form is auto generated as below.<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/varForms_2.jpg"></img><p class="paragraph"/>To create a manual form, select Use Custom Form, a text box appears for entering html code for the form. Enter the
manual form code and click button 'Generate'<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/varForms_3.jpg"></img><p class="paragraph"/>
To create a manual form with a controller select the option Use Custom Controller and Form and enter the code for
Manual form and controller and click button 'Generate'<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/varForms_4.jpg"></img><p class="paragraph"/><p class="paragraph"/>If the editor is an external one, select Use External Editor option and enter the URL for the same.<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/varForms_5.jpg"></img><p class="paragraph"/>
 Example:
<ul class="star">
<li>Views Section</li>
<ul class="star">
<li>size</li>
<li>widget</li>
<li>rows</li>
<li>cols</li>
<li>styleClass</li>
<li>template</li>
<li>displayKey</li>
<li>remoteFields</li>
<li>dateFormat</li>
<li>restriction</li>
</ul>
<li>Descriptions Section</li>
<ul class="star">
<li>description_(en|de|fr|...)</li>
<li>label_(en|de|fr|...)</li>
</ul>
<li>Constraints Section</li>
<ul class="star">
<li>required</li>
</ul></ul><p class="paragraph"/>Example:<p class="paragraph"/><div class="code"><pre>class AutoFormsGenerationTestProcess &#123;
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span>  productId
    <span class="java&#45;keyword">public</span> Link userSite
    <span class="java&#45;keyword">public</span> Address address
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> commentary<p class="paragraph"/> 
    <span class="java&#45;keyword">static</span> views = &#123;
        // the order of fields is taken into account when form auto generates,
        // <span class="java&#45;keyword">if</span> the property is not specified in <span class="java&#45;keyword">this</span> section it will be displayed
        // below specified properties<p class="paragraph"/>        address(widget: <span class="java&#45;quote">"externalSearch"</span>, template: <span class="java&#45;quote">"search/address.gsp"</span>,
        displayKey: <span class="java&#45;quote">"addressID"</span>, remoteFields: <span class="java&#45;quote">"name1,city"</span>)
        commentary(widget: <span class="java&#45;quote">"textarea"</span>)
        productId(size:35)
    &#125;<p class="paragraph"/> 
    <span class="java&#45;keyword">static</span> descriptions = &#123;
        AutoFormsGenerationTest(description_en: <span class="java&#45;quote">"<span class="java&#45;object">Process</span> workflow shows automatic forms generation."</span>,
        description_de: <span class="java&#45;quote">"<span class="java&#45;object">Process</span> workflow shows automatic forms generation."</span>)
        address(description_en: <span class="java&#45;quote">"You can specify address here."</span>, description_de: <span class="java&#45;quote">"You can specify address here."</span>,
        label_en: <span class="java&#45;quote">"Address"</span>, label_de: <span class="java&#45;quote">"Address"</span>)
        productId(label_en: <span class="java&#45;quote">"Product ID"</span>, label_de: <span class="java&#45;quote">"Product ID"</span>)
   &#125;<p class="paragraph"/> 
   <span class="java&#45;keyword">static</span> constraints = &#123;
       productId(required:<span class="java&#45;keyword">true</span>)
       address(required:<span class="java&#45;keyword">true</span>)
   &#125;</pre></div><p class="paragraph"/>
<strong class="bold">Grailsflow Auto Forms Generation</strong><p class="paragraph"/><strong class="bold">size</strong><p class="paragraph"/>Usage: Uses a value to restrict the size of property input field
Example:
<div class="code"><pre>productID(size: 35)</pre></div><p class="paragraph"/><strong class="bold">widget</strong><p class="paragraph"/>Usage: specifies the widget that represents this process variable property,
Possible values:
<ol>
<li>textarea</li>
<li>externalSearch</li>
<li>list</li>
</ol><p class="paragraph"/>Example:
<div class="code"><pre>commentary(widget: <span class="java&#45;quote">"textarea"</span>)
address(widget: <span class="java&#45;quote">"externalSearch"</span>)<p class="paragraph"/>status(widget: <span class="java&#45;quote">"list"</span>)</pre></div><p class="paragraph"/><strong class="bold">External Search:</strong>  If you want to use widget 'externalSearch', it is also important to specify the 'displayKey' and
'template' attributes, because they specify the template and bean property for rendering.<p class="paragraph"/>The mechanism of external search rendering is as follows: property is rendered as readonly input with 'search' and
'clear' link-icons.  By clicking the 'search' link - you see the pop-up window with a 'template' page. It can be the
page with the search form or it can contain the list of all available values for the property and the user has the
option to possibily select one. Then the inputs of the property are pre-selected with these values. The requirements
for the template page are:
<ul class="star">
<li> The template before closing should call opener function, the name of this function is available in the template as</li>
</ul><p class="paragraph"/>the 'callbackFunctionName' parameter. Also in the template,  there are some more available parameters, they are: ID0 -
the identifier property of the preselected value. fieldName0 - the property name (process variable name).
<ul class="star">
<li> It is possible to rewrite and create your own function that fills the opener inputs with selected value. But in this</li>
</ul><p class="paragraph"/>case you need to know how the widget Id's are formed.
<ul class="star">
<li> Pay attention how the opener inputs can be filled: if you want to call opener function, you should transmit some</li>
</ul><p class="paragraph"/>params with the function since this is the: 'key' - the identifier property of your selected values and any other
parameters that have the same names as properties of variable (specified as displayKey and remoteFields properties
names), for example: key = 3 - the unique identifier of Address object. addressId = 'MIRAX GROUP' - value of Address
display Key property city = 'London' - the value of city property street= 'Piccadilly' - the value of street property
If you want to fill owner fields with you own JavaScript function, please pay attention how the opener widgits Id's are
formed. The key property with Id '${propertyName}' for opener window, the remoteFields have the following ID structure:<p class="paragraph"/>
${propertyName}_${remoteField}, for example:
<div class="code"><pre>opener.document.getElementById(<span class="java&#45;quote">"address"</span>).value = 3
    opener.document.getElementById(<span class="java&#45;quote">"address_addressId"</span>).value = addressID
    opener.document.getElementById(<span class="java&#45;quote">"address_city"</span>).value = city
    opener.document.getElementById(<span class="java&#45;quote">"address_street"</span>).value = street</pre></div><p class="paragraph"/>List: If you want to use widget 'list', you can also specify 'displayKey' and 'restriction' attributes.<p class="paragraph"/><strong class="bold">rows</strong><p class="paragraph"/>Usage: defines the number of rows for textarea widget
Example:
<div class="code"><pre>commentary(rows: 10)</pre></div><p class="paragraph"/><strong class="bold">cols</strong><p class="paragraph"/>Usage: defines the number of columns for textarea widget
Example:
<div class="code"><pre>commentary(cols: 50)</pre></div><p class="paragraph"/><strong class="bold">styleClass</strong><p class="paragraph"/>Usage: defines which style class should be applied for widget
Example:
<div class="code"><pre>productId(styleClass: <span class="java&#45;quote">"productEntry"</span>)</pre></div><p class="paragraph"/><strong class="bold">template</strong><p class="paragraph"/>Usage: this property is important for externalSearch, it describes path to template that will use for external search
Example:
<div class="code"><pre>address(template: <span class="java&#45;quote">"search/address.gsp"</span>)</pre></div><p class="paragraph"/><strong class="bold">displayKey</strong><p class="paragraph"/>Usage: this property is important for externalSearch and list widgets, if it's specified then selected value is represented by this property of bean.
Example:
<div class="code"><pre>address(displayKey: <span class="java&#45;quote">"addressId"</span>)</pre></div><p class="paragraph"/><strong class="bold">remoteFields</strong><p class="paragraph"/>Usage: this property is important for externalSearch, the properties names are comma-separated, specifies additional fields which are displayed on UI
Example:
<div class="code"><pre>address(remoteFields: <span class="java&#45;quote">"city, street"</span>)</pre></div><p class="paragraph"/><strong class="bold">dateFormat</strong><p class="paragraph"/>Usage: can be useful for properties of type Date, there we can specify the pattern for date, e.g. 'y-m-d H:i:s'
Example:
<div class="code"><pre>startDate(dateFormat: <span class="java&#45;quote">"y&#45;m&#45;d H:i:s"</span>)</pre></div><p class="paragraph"/><strong class="bold">restriction</strong><p class="paragraph"/>Usage: can be useful if you specify widget list. In this case in restriction input you can write restrictions for list values.
Example:
<div class="code"><pre>address(widget: <span class="java&#45;quote">"list"</span>, restriction: <span class="java&#45;quote">"address.city = 'Berlin'"</span>)</pre></div><p class="paragraph"/>It means that in list should be shown only addresses with property City ='Berlin'<p class="paragraph"/><strong class="bold">description</strong><p class="paragraph"/>Usage: specifies the description for process or process variable property
Example:
<div class="code"><pre>commentary(description_en: <span class="java&#45;quote">"Put your commentary here."</span>, description_de: <span class="java&#45;quote">"Put your commentary here."</span>)</pre></div><p class="paragraph"/><strong class="bold">label</strong><p class="paragraph"/>Usage: specifies the label for property or node event
Example:
<div class="code"><pre>catalogId(label_en: <span class="java&#45;quote">"Product Catalog ID"</span>, lable_de: <span class="java&#45;quote">"Product Catalog ID"</span>)<p class="paragraph"/>Set(label_en: <span class="java&#45;quote">"Set Values"</span>, label_de: <span class="java&#45;quote">"Set Values"</span>)</pre></div><p class="paragraph"/><strong class="bold">required</strong><p class="paragraph"/>Usage: set to true if the property value is required
Example:
<div class="code"><pre>productId(required:<span class="java&#45;keyword">true</span>)</pre></div>


<h2 id="manualForms">4.6 Manual Forms</h2>
<strong class="bold">Why do we use Manual Forms</strong><p class="paragraph"/>Sometimes it’s not convenient to use Grailsflow automatic forms for process flow. They have a number of restrictions.<p class="paragraph"/>All automatic forms have the same layout: the list of variables and the list of available events. In Grailsflow, there
is a possibility to create manual or custom forms. On your manual form you can use any styles, scripts, functionality.
See example.<p class="paragraph"/>Automatic form for HolidayRequest process definitions:<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_1.jpg"></img><p class="paragraph"/>Custom form for the same process definition:<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_2.jpg"></img><p class="paragraph"/><strong class="bold">Based on Grails: Groovy + GSPs</strong><p class="paragraph"/>The manual form creation if based on Groovy and GSP concepts - The manual (or custom) form is a GSP template that will
be rendered on the ‘Node Details’ page. When you decide that you need to create a form, the following links about
Grails, Groovy and GSP (groovy server pages) can be useful for you:
<ul class="star">
<li><a href="http://www.grails.org/" target="blank">http://www.grails.org/</a></li>
<li><a href="http://groovy.codehaus.org/" target="blank">http://groovy.codehaus.org/</a></li>
<li><a href="http://groovy.codehaus.org/GSP" target="blank">http://groovy.codehaus.org/GSP</a></li>
</ul><p class="paragraph"/><strong class="bold">How to create Manual Forms and integrate into Process definition</strong><p class="paragraph"/>When you decide that you need a manual instead of an automatic form for your node, there are two ways to do it:
<ul class="star">
<li> Create simple Manual form;</li>
<li> Create Manual form with Custom Controller</li>
</ul><p class="paragraph"/>The information for the second (Create Manual form with Custom Controller) option  can be found in chapter 11. This
feature works only in development mode.<p class="paragraph"/>When you finish with the form and press the ‘Generate’ button, the GSP template is generated and stored in the
application views. When the node is activated, the manual form will be rendered to the user. Each form belongs to the
process node and stored in views as - path‘views/manualForms/&#60;ProcessType&#62;/_&#60;ProcessNode&#62;.gsp’.
The Manual form is rendered as the part of the 'Node Details' page. Only server messages (standard error messages) can
be added to the page automatically (at the top of the page). If your form cannot be rendered, the error message will be
displayed.<p class="paragraph"/>
<strong class="bold">Access of Process Variables</strong><p class="paragraph"/>On the manual form you can access all process variables. They are in bean ‘nodeDetails’ that is available on the manual
form. You can get them by using the following signature:<p class="paragraph"/>${nodeDetails.variables}<p class="paragraph"/>Where 'variables' is a Map that contains entries
variableName: variableDetails
VariableDetails bean contains the following list of properties:
<ul class="star">
<li>   <strong class="bold">name</strong>           String variable name</li>
<li>   <strong class="bold">typeName</strong>  (changed to <strong class="bold">type</strong> since version 1.0)   type of variable</li>
<li>   <strong class="bold">label</strong>            Map of languageID -&#62; variable label</li>
<li>   <strong class="bold">description</strong>   Map of languageID -&#62; variable description</li>
<li>   <strong class="bold">value</strong>           Object variable value</li>
<li>   <strong class="bold">visibility</strong>        Variable visibility</li>
<li>   <strong class="bold">required</strong>      Is variable required or not</li>
<li>   <strong class="bold">view</strong>             View of variable (See more information in chapter 8)</li>
</ul><p class="paragraph"/>For example, you can access property 'value' of variable using the following notation:
${nodeDetails.variables.requesterName.value}<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_3.jpg"></img><p class="paragraph"/>If you want your variable to be updated after form submitting you need to follow the rule that variable should have
property 'name' specified like:<p class="paragraph"/>name="var_&#60;variableName&#62;".<p class="paragraph"/>
<strong class="bold">Available Events (transitions)</strong><p class="paragraph"/>Also on the manual forms you can get information about all available transitions from current node. They are stored in
bean ‘nodeDetails’ and can be accessed using signature:<p class="paragraph"/>${nodeDetails.events}<p class="paragraph"/>Where "events" is a set of objects. Each object contains the next information about transition:
<ul class="star">
<li>   event;</li>
<li>   label (the Map of entries: languageID -&#62; event label) - it is used for making events translatable.</li>
</ul><p class="paragraph"/>    If you want to use transition on UI you need to take into account the following rule: your HTML submit component
    should have property ‘name’ specified like
    name = “event_&#60;event&#62;” .<p class="paragraph"/>See example:<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_4.jpg"></img><p class="paragraph"/>Pay attention, that if you want to submit any information to the server you need to place it in  &#60;g:form&#62; tag. For more
information check <a href="http://www.grails.org/Tag+-+form" target="blank">http://www.grails.org/Tag+-+form</a>.<p class="paragraph"/><strong class="bold">Available Beans and Services</strong><p class="paragraph"/>There is a bean "nodeDetails" that is available on manual form. This bean is of type
com.jcatalog.grailsflow.engine.NodeDetails and contains the following info:<p class="paragraph"/>NodeDetails has following properties:
<ul class="star">
<li>   process        Object contains information about process</li>
<li>   nodeID         String node ID</li>
<li>   label             Map of  languageID -&#62; node label</li>
<li>   description    Map of languageID -&#62; node description</li>
<li>   caller            String node caller</li>
<li>   status            FlowStatus node status</li>
<li>   startedOn      Date node startedOn</li>
<li>   dueOn           Date node dueOn</li>
<li>   assignees      Set&#60;String&#62;   of assignee IDs</li>
<li>   events           Set&#60;EventDetails&#62; of events</li>
<li>   variables        Map of variableName -&#62; variableDetails</li>
</ul><p class="paragraph"/><strong class="bold">How to access DB entries</strong><p class="paragraph"/>On the custom form it is possible to access database instances using standard Grails possibilities (working with
domains) and Groovy tags:
<div class="code"><pre>&#60;g:select from=<span class="java&#45;quote">"$&#123;com.jcatalog.core.Country.list()&#125;"</span>
          optionKey=<span class="java&#45;quote">"countryId"</span>
          optionValue=<span class="java&#45;quote">"countryId"</span>
          value=<span class="java&#45;quote">"$&#123;orderAddress?.country&#125;"</span>/&#62;</pre></div><p class="paragraph"/>This example shows how to create selectbox with Countries (countryID are shown).<p class="paragraph"/>If you need to access the DB table, you need to specify the domain class (full class name) and then call one of the
dynamic methods that Grails provides for domains.<p class="paragraph"/>For example, you can get all entries from table Product:<p class="paragraph"/><div class="code"><pre>com.jcatalog.product.Product.list()</pre></div><p class="paragraph"/>or find products using some filters:
<div class="code"><pre>com.jcatalog.product.Product.findAllByProductIdLike(“%Printer%”)<p class="paragraph"/>com.jcatalog.product.Product.findWhere(productId:“Printer”, catalogId: “HP”)</pre></div><p class="paragraph"/>For more information about available dynamic methods,  see  <a href="http://grails.org/DomainClass+Dynamic+Methods" target="blank">http://grails.org/DomainClass+Dynamic+Methods</a> .<p class="paragraph"/>
<strong class="bold">Custom tags provided by Grailsflow</strong><p class="paragraph"/>For the automatic form you can specify ‘view’ and default values for each process variable. For the manual form you can
use all the same ‘views’ or tags. Among them:
<ul class="star">
<li>   SimpleView</li>
<li>   TextAreaView</li>
<li>   SelectBoxView</li>
<li>   CheckBoxView</li>
<li>   DateView</li>
<li>   LinkView</li>
<li>   DocumentView</li>
<li>   ListObjectsView</li>
<li>   ExternalSearchObjectView</li>
<li>   DefaultView</li>
</ul><p class="paragraph"/>TThe 'view' property can be specified for each process variable in the variable editor. Then, if you specify the view,
you can ask Grailsflow to use this 'view' for rendering the variable. For this reason, you can use 'variableInput'
Grailsflow tag (implemented in developing version):<p class="paragraph"/><div class="code"><pre>&#60;gf:variableInput variable=<span class="java&#45;quote">"$&#123;variable&#125;"</span>/&#62;</pre></div><p class="paragraph"/>If you do not specify 'view' templates for each process variable you can use view templates directly on the manual page:<p class="paragraph"/><div class="code"><pre>&#60;g:customizingTemplate
 template=<span class="java&#45;quote">"$&#123; com.jcatalog.grailsflow.model.view.CheckBoxView.template&#125;”
 model="</span>&#91;variable: variable, view: variable.view, parameterName: parameterName&#93;"/&#62;</pre></div><p class="paragraph"/>In the tag there are the following parameters:
<ul class="star">
<li>   template (that is the template that should be used for variable rendering);</li>
<li>   model (the information that will be available on the template.)</li>
</ul><p class="paragraph"/>The template requires ‘variable’ for rendering, ‘view’, and ‘parameterName’ – it provides to the server the name of the
variable for updating DB entries after submitting.)<p class="paragraph"/>Please see the example how to get ExternalSearchObjectView for variable.<p class="paragraph"/>You can use the following notations:
<div class="code"><pre>&#60;gf:variableInput variable=<span class="java&#45;quote">"$&#123;variable&#125;"</span>/&#62;</pre></div><p class="paragraph"/>Use this notation when variable 'view' and all necessary parameters for displaying external search (like displayKey,
URL for search) are specified in process script.
Also it's possible to get external search component using tag 'customizingTemplate':
<div class="code"><pre>&#60;g:customizingTemplate
 template=<span class="java&#45;quote">"$&#123;com.jcatalog.grailsflow.model.view.ExternalSearchObjectView.template&#125;”
 model="</span>&#91;variable: variable, view: variable.view, parameterName: parameterName&#93;"/&#62;</pre></div><p class="paragraph"/>In that case, all parameters that are necessary for ExternalSearchObjectView (e.g. displayKey, URL for external search)
will be taken from ‘variable.view’ object. But pay attention in that case you need to specify all these attributes for
the variable in Process Variable Editor.<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_5.jpg"></img><p class="paragraph"/>If you did not configure 'View' for the process variable definition, it is possible to use External search too. You can
do it using Grails &#60;g:render&#62; tag. For ExternalSearchObjectView there are three parameters that you can specify:
<ul class="star">
<li>   displayKey (property for display in input field);</li>
<li>   searchUrl (is necessary, URL for external search page);</li>
<li>   additionalFields (Additional fields for displaying, they are usually displayed as readonly fields.);</li>
</ul><p class="paragraph"/>The following example should show external search component for Address object.
<div class="code"><pre>&#60;g:render contextPath=<span class="java&#45;quote">"$&#123;pluginContextPath&#125;"</span>
 template=<span class="java&#45;quote">"/variableViewTempaltes/externalSearchObjectView"</span>
 model=<span class="java&#45;quote">"&#91;variable:nodeDetails.variables.address,
 view:<span class="java&#45;keyword">new</span> com.jcatalog.grailsflow.model.view.ExternalSearchObjectView(displayKey:'addressID',
 searchUrl: 'search/address.gsp',
 additionalFields: 'name1, city'),
 parameterName: 'externalSearchObjectView_address'&#93;"</span>/&#62;</pre></div><p class="paragraph"/>Where:
<ul class="star">
<li>   contextPath      Path for template searching</li>
<li>   template         Template for rendering</li>
<li>   model            Information that should be available for the template</li>
</ul><p class="paragraph"/>In the 'model' you put 'variable' object. As you do not have a view specified for the variable, we can create it:
<div class="code"><pre><span class="java&#45;keyword">new</span> com.jcatalog.grailsflow.model.view.ExternalSearchObjectView(…)</pre></div><p class="paragraph"/>In the brackets, it is possible to define properties for this 'view'.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> com.jcatalog.grailsflow.model.view.ExternalSearchObjectView(displayKey: 'addressID', searchUrl: 'search/address.gsp', additionalFields: 'name1, city')</pre></div><p class="paragraph"/>As mentioned before, the events and variables have Maps of labels and descriptions (only variables have descriptions).
You can show the labels and descriptions according to the requested locale using Grailsflow tag 'translatedValue'’.<p class="paragraph"/>For example:
<div class="code"><pre>&#60;g:translatedValue translations=<span class="java&#45;quote">"$&#123;variable.label&#125;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"$&#123;variable.name&#125;"</span> /&#62;</pre></div><p class="paragraph"/>or
<div class="code"><pre>&#60;g:translatedValue translations=<span class="java&#45;quote">"$&#123;variable.description&#125;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">""</span> /&#62;</pre></div><p class="paragraph"/><strong class="bold">How to include user owned GSP templates</strong><p class="paragraph"/>It is possible to include your own prepared templates into the manual form.You can do it using Grailsflow tag
“customizingTemplate”.
<div class="code"><pre>&#60;g:customizingTemplate template=<span class="java&#45;quote">"/myForms/eventForwarding"</span> model=<span class="java&#45;quote">"&#91;currentAssignees: nodeDetails.assignees&#93;"</span>/&#62;</pre></div><p class="paragraph"/><strong class="bold">Customize Return Controller and Action</strong><p class="paragraph"/>By default, after the manual step form execution, you will be forwarded to the Process Details page. You can customize
this behavior by specifying the return controller and action in your manual page. For example you can set it to
'showWorklist' - this means that after form submission, you will be redirected to the Worklist page. Please see the
following example:<p class="paragraph"/><div class="code"><pre>&#60;input type=<span class="java&#45;quote">"hidden"</span> name=<span class="java&#45;quote">"returnController"</span> value=<span class="java&#45;quote">"process"</span>/ &#62;
&#60;input type=<span class="java&#45;quote">"hidden"</span> name=<span class="java&#45;quote">"returnAction"</span> value=<span class="java&#45;quote">"showWorklist"</span>/ &#62;</pre></div><p class="paragraph"/>Releases of Grailsflow-1.0 and higher use parameters 'resultController', 'resultAction' instead of 'returnController',
'returnAction'.<p class="paragraph"/><strong class="bold">Multi-Step pages</strong><p class="paragraph"/>This feature works only in the development mode of Grails. It makes it possible to enhance process flow (add some
additional functionality and steps) without changing process definition. This can be done by using multi-step page. For
this, you need to select ‘Use Custom Controller and Form’ in Node Editor. In that case your ‘manual form’ content
(entered in the textarea) will be rendered as the first step. It should contain links/buttons that leads to the actions
in your Custom Controller. Your Custom Controller can make some actions and then render the next ‘step page’ (page can
be created using the ‘Add Multi-Step Page’ link). This step can lead to the Custom Controller and the Controller will
render the next step or redirect to the Grailsflow controller and continue the flow.<p class="paragraph"/>Multi-Step page belongs to the node and stored in the views under path, see some screenshots:<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_6.jpg"></img><p class="paragraph"/>Add one more Step:<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_7.jpg"></img><p class="paragraph"/>Multi-Step page belongs to node and stored in the views under path:<p class="paragraph"/>‘views/&#60;ProcessType&#62;&#60;ProcessNode&#62;/&#60;StepName&#62;.gsp’,<p class="paragraph"/>Pay attention that the name for the controller is generated by Grailsflow and it has view:<p class="paragraph"/>&#60;ProcessID_NodeID&#62;Controller.groovy<p class="paragraph"/>In the example above you can see that the form has “controller = ‘test_SetValues’”. Where ‘Test’ – is a name of Process,
and ‘SetValues’ is a name of node for which you prepare the manual form.<p class="paragraph"/>Pay attention that manual (or custom) form is included  in GSP page as template. This template is included in<p class="paragraph"/>&#60;g:form action="sendEvent" controller="process" ...&#62;  tag, it means that you should not use more forms in your manual
page. If you need to submit other form action you can use JavaScript features to change form action and controller.
For example:
<div class="code"><pre>&#60;input type=<span class="java&#45;quote">"button"</span> onclick=<span class="java&#45;quote">" <span class="java&#45;keyword">this</span>.form.action = ...; form.submit(); "</span> /&#62;</pre></div>


<h2 id="manualFormsActions">4.7 Manual Forms Actions</h2>
<h4>Manual Forms Actions</h4><p class="paragraph"/>From version Grailsflow-core-1.2.7 it is recommended to have manual nodes without actions (it means without closure
<strong class="bold">action</strong> at all).<p class="paragraph"/>We assume that manual node is the form (automatic or manual) and it should not contain any Groovy code for execution.
The Wait node is only used to prepare user form, get new values for process variables and define next transition.
If you need any kind of validation for process variables or some other code, please define it in the next 'Activity'
node.<p class="paragraph"/>But these changes should be compatible with the previous versions of Grailsflow (where manual nodes can have code). It
means that in case if 'Wait' node has <strong class="bold">action{}</strong> closure, the engine will execute it, but write warning, for example
 <em class="italic">'WARNING! The action{} closure is deprecated in manual node definition! Such code may lead to system dead locks.'</em> <p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_8.jpg"></img><p class="paragraph"/>Also, there is a notification about manual forms actions in Process Editor (Action Editor):<p class="paragraph"/><img border="0" class="center" src="../img/developersGuide/manualForms_9.jpg"></img><p class="paragraph"/>


<h2 id="postKillHandler">4.8 PostKillOperation Handler</h2>
<h4>PostKillProcessHandler</h4><p class="paragraph"/>There is a possibility to define some necessary activity in case of process killing (e.g. close connections, send emails,
etc.). In that case you can implement class with interface <strong class="bold">PostKillProcessHandler</strong>
(com.jcatalog.grailsflow.process.PostKillProcessHandler) and write your code in its method <strong class="bold">handle</strong> and then define bean
<strong class="bold">postKillProcessHandler</strong> in application Spring context.<p class="paragraph"/>By default this bean is not configured  - so there is no activity in case of process killing. In case if bean
<strong class="bold">postKillProcessHandler</strong> is defined, the postKillProcessHandler should be called after process interruption but before
saving <strong class="bold">KILLED</strong> status for process and nodes. In case if process cannot be killed successfully (e.g. status 'KILLING')
no activity is called.<p class="paragraph"/>



<h2 id="customizeDueDate">4.9 Customize Due Dates calculation</h2>
<strong class="bold">Customize Due Date calculation</strong><p class="paragraph"/>It is a possible to customize Due Date calculation for Process Nodes and configure calculation behaviour for all
processes or for certain Process Type. By default, the process node due date calculated as:<p class="paragraph"/><div class="code"><pre>node.dueOn = node.startedOn + nodeDef.dueDate</pre></div><p class="paragraph"/>where
<ul class="star">
<li>node.startedOn - <strong class="bold">Date</strong> when node was ACTIVATED.</li>
<li>nodeDef.dueDate - <strong class="bold">Long</strong> value from process definition.</li>
</ul><p class="paragraph"/>Sometimes, it is necessary to change behaviour - e.g. if the <strong class="bold">dueDate</strong> (node.,dueOn) is a weekend, it will need to be
shifted. Use the <strong class="bold">Config.groovy</strong> file of your application to configure <strong class="bold">Due Date</strong> calculation.<p class="paragraph"/><div class="code"><pre>grailsflow.customizedDueDate = &#123; Date dueDate &#45;&#62;
     Calendar date = Calendar.getInstance()
     date.setTime(dueDate)
     <span class="java&#45;keyword">if</span> (date.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) &#123;
         date.add(Calendar.DATE, 2)
         <span class="java&#45;keyword">return</span> date.time
     &#125; <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">if</span> (date.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)&#123;
         date.add(Calendar.DATE, 1)
         <span class="java&#45;keyword">return</span> date.time
     &#125; <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">return</span> date.time
&#125;</pre></div><p class="paragraph"/>Or also it is possible to do for certain <strong class="bold">Process Type</strong>:<p class="paragraph"/><div class="code"><pre>grailsflow.HolidayRequest.customizedDueDate = &#123; Date dueDate &#45;&#62;
     Calendar date = Calendar.getInstance()
     date.setTime(dueDate)
     <span class="java&#45;keyword">if</span> (date.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) &#123;
         date.add(Calendar.DATE, 2)
         <span class="java&#45;keyword">return</span> date.time
     &#125; <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">if</span> (date.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)&#123;
         date.add(Calendar.DATE, 1)
         <span class="java&#45;keyword">return</span> date.time
     &#125; <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">return</span> date.time
 &#125;</pre></div>



                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/usersGuide.html">&lt;&lt; <strong>3</strong><span>User's Guide</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/faq.html"><strong>5</strong><span>Frequently Asked Questions</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    jCatalog Software AG
    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
